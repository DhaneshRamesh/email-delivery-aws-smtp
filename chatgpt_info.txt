===== src/api/app.py =====
"""FastAPI application instance."""
from __future__ import annotations

from contextlib import asynccontextmanager

from fastapi import FastAPI
from fastapi.middleware.cors import CORSMiddleware

from src.api.routes import campaigns, domains, send, subscribers
from src.core.config import settings
from src.db import models
from src.db.session import engine
from src.utils.logger import configure_logging


@asynccontextmanager
async def lifespan(app: FastAPI):  # pragma: no cover - startup hook
    configure_logging()
    # Ensure tables exist for local development. Alembic should manage in production.
    models.Base.metadata.create_all(bind=engine)
    yield


app = FastAPI(
    title=settings.app_name,
    version=settings.api_version,
    lifespan=lifespan,
)

app.add_middleware(
    CORSMiddleware,
    allow_origins=settings.allowed_origins,
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

app.include_router(send.router)
app.include_router(campaigns.router)
app.include_router(subscribers.router)
app.include_router(domains.router)


@app.get("/health", tags=["system"])
async def health() -> dict[str, str]:
    """Simple uptime check."""

    return {"status": "ok"}


===== src/db/models.py =====
"""Database models for the email delivery platform."""
from __future__ import annotations

from datetime import datetime

from sqlalchemy import Boolean, Column, DateTime, ForeignKey, Integer, String, Text, func
from sqlalchemy.orm import declarative_base, relationship

Base = declarative_base()


class Tenant(Base):
    __tablename__ = "tenants"

    id = Column(Integer, primary_key=True, index=True)
    name = Column(String(255), unique=True, nullable=False)
    contact_email = Column(String(320), nullable=False)
    ses_verified = Column(Boolean, default=False)
    created_at = Column(DateTime(timezone=True), server_default=func.now())

    campaigns = relationship("Campaign", back_populates="tenant", cascade="all, delete-orphan")
    subscribers = relationship("Subscriber", back_populates="tenant", cascade="all, delete-orphan")


class Campaign(Base):
    __tablename__ = "campaigns"

    id = Column(Integer, primary_key=True)
    tenant_id = Column(Integer, ForeignKey("tenants.id"), nullable=False, index=True)
    name = Column(String(255), nullable=False)
    subject = Column(String(255), nullable=False)
    body = Column(Text, nullable=False)
    status = Column(String(50), default="draft")
    scheduled_at = Column(DateTime(timezone=True), nullable=True)
    created_at = Column(DateTime(timezone=True), server_default=func.now())

    tenant = relationship("Tenant", back_populates="campaigns")
    email_logs = relationship("EmailLog", back_populates="campaign")


class Subscriber(Base):
    __tablename__ = "subscribers"

    id = Column(Integer, primary_key=True)
    tenant_id = Column(Integer, ForeignKey("tenants.id"), nullable=False)
    email = Column(String(320), nullable=False, index=True)
    first_name = Column(String(120), nullable=True)
    last_name = Column(String(120), nullable=True)
    status = Column(String(50), default="active")
    created_at = Column(DateTime(timezone=True), server_default=func.now())

    tenant = relationship("Tenant", back_populates="subscribers")


class EmailLog(Base):
    __tablename__ = "email_logs"

    id = Column(Integer, primary_key=True)
    tenant_id = Column(Integer, ForeignKey("tenants.id"), nullable=False)
    campaign_id = Column(Integer, ForeignKey("campaigns.id"), nullable=True)
    subscriber_id = Column(Integer, ForeignKey("subscribers.id"), nullable=True)
    message_id = Column(String(255), nullable=False)
    status = Column(String(50), default="queued")
    sent_at = Column(DateTime(timezone=True), default=datetime.utcnow)
    created_at = Column(DateTime(timezone=True), server_default=func.now())

    campaign = relationship("Campaign", back_populates="email_logs")


===== src/services/ses.py =====
"""AWS SES helper functions."""
from __future__ import annotations

from typing import Optional

try:  # pragma: no cover - optional dependency import
    import boto3
    from botocore.exceptions import BotoCoreError, ClientError
except ImportError:  # pragma: no cover
    boto3 = None  # type: ignore

    class BotoCoreError(Exception):
        """Fallback exception when botocore is unavailable."""

    class ClientError(Exception):
        """Fallback exception when botocore is unavailable."""

from src.core.config import settings
from src.utils.logger import logger


class SESService:
    """Encapsulates the boto3 SES client."""

    def __init__(
        self,
        aws_access_key_id: str | None = None,
        aws_secret_access_key: str | None = None,
        region_name: str | None = None,
    ) -> None:
        self.aws_access_key_id = aws_access_key_id or settings.aws_access_key_id
        self.aws_secret_access_key = aws_secret_access_key or settings.aws_secret_access_key
        self.region_name = region_name or settings.aws_region_name
        self._client = None

    def _client_or_raise(self):
        if self._client is None:
            if boto3 is None:  # pragma: no cover - dependency notice
                raise RuntimeError("boto3 is required for SES operations. Install project dependencies.")
            self._client = boto3.client(
                "ses",
                region_name=self.region_name,
                aws_access_key_id=self.aws_access_key_id,
                aws_secret_access_key=self.aws_secret_access_key,
            )
        return self._client

    def send_email(
        self,
        *,
        subject: str,
        recipient: str,
        text_body: str,
        html_body: Optional[str] = None,
        sender: Optional[str] = None,
    ) -> str:
        """Send an email and return the SES message ID."""

        client = self._client_or_raise()
        try:
            response = client.send_email(
                Source=sender or settings.ses_sender_email,
                Destination={"ToAddresses": [recipient]},
                Message={
                    "Subject": {"Data": subject},
                    "Body": {
                        "Text": {"Data": text_body},
                        "Html": {"Data": html_body or text_body},
                    },
                },
            )
        except (BotoCoreError, ClientError) as exc:  # pragma: no cover - network service
            logger.exception("Failed to send email via SES")
            raise RuntimeError("SES send_email failed") from exc

        message_id = response.get("MessageId", "")
        logger.info("SES send_email message_id=%s", message_id)
        return message_id


ses_service = SESService()


===== src/queue/worker.py =====
"""RQ worker that delivers outbound emails via SES."""
from __future__ import annotations

from typing import Any

try:  # pragma: no cover - optional dependency import
    import redis  # type: ignore
except ImportError:  # pragma: no cover
    redis = None  # type: ignore

try:  # pragma: no cover
    from rq import Connection, Queue, Worker  # type: ignore
except ImportError:  # pragma: no cover
    Connection = Queue = Worker = None  # type: ignore

from src.core.config import settings
from src.services.ses import SESService
from src.utils.logger import logger

_email_queue: Any | None = None


def _ensure_dependencies() -> None:
    if redis is None or Queue is None or Worker is None:
        raise RuntimeError(
            "redis and rq packages are required for queue processing. Install project dependencies."
        )


def _get_queue() -> Any:
    global _email_queue
    if _email_queue is None:
        _ensure_dependencies()
        connection = redis.Redis.from_url(settings.redis_url)  # type: ignore[union-attr]
        _email_queue = Queue("emails", connection=connection)  # type: ignore[call-arg]
    return _email_queue


def process_email_job(*, subject: str, recipient: str, body: str) -> str:
    """Background job that sends an email."""

    service = SESService()
    message_id = service.send_email(subject=subject, recipient=recipient, text_body=body)
    logger.info("Processed queued email to %s", recipient)
    return message_id


def enqueue_email_job(*, subject: str, recipient: str, body: str):
    """Helper for API routes to enqueue jobs."""

    queue = _get_queue()
    return queue.enqueue(
        process_email_job,
        kwargs={"subject": subject, "recipient": recipient, "body": body},
    )


def run_worker() -> None:
    """Entry point called by `python -m src.queue.worker`."""

    queue = _get_queue()
    connection = queue.connection
    with Connection(connection):  # type: ignore[arg-type]
        worker = Worker([queue])
        worker.work(with_scheduler=True)


if __name__ == "__main__":  # pragma: no cover - manual execution
    run_worker()


===== src/api/routes/send.py =====
"""Routes for sending transactional emails."""
from __future__ import annotations

from fastapi import APIRouter
from pydantic import BaseModel, field_validator

from src.core.config import settings
from src.core.rate_limit import create_rate_limiter
from src.queue.worker import enqueue_email_job
from src.services.ses import ses_service

router = APIRouter(prefix="/send", tags=["send"])
_rate_limiter = create_rate_limiter(settings.rate_limit_per_minute)


class SendTestRequest(BaseModel):
    recipient: str
    subject: str
    body: str
    enqueue: bool = False

    @field_validator("recipient")
    @classmethod
    def validate_recipient(cls, value: str) -> str:
        if "@" not in value:
            raise ValueError("recipient must be an email address")
        return value


class SendTestResponse(BaseModel):
    message_id: str
    queued: bool = False


@router.post("/send-test", response_model=SendTestResponse)
async def send_test_email(request: SendTestRequest) -> SendTestResponse:
    """Send a simple email via AWS SES."""

    await _rate_limiter.check("global-test")

    if request.enqueue:
        job = enqueue_email_job(
            subject=request.subject,
            recipient=request.recipient,
            body=request.body,
        )
        return SendTestResponse(message_id=job.id, queued=True)

    message_id = ses_service.send_email(
        subject=request.subject,
        recipient=request.recipient,
        text_body=request.body,
    )
    return SendTestResponse(message_id=message_id, queued=False)


===== src/core/config.py =====
"""Application configuration powered by environment variables."""
from __future__ import annotations

from functools import lru_cache
from typing import List

from dotenv import load_dotenv
from pydantic import field_validator
from pydantic_settings import BaseSettings, SettingsConfigDict

# Load variables from a local .env file if present. This keeps runtime flexible.
load_dotenv()


class Settings(BaseSettings):
    """Strongly typed configuration for the service."""

    app_name: str = "CourierX"
    environment: str = "development"
    api_version: str = "v1"
    database_url: str = "sqlite:///./data/email_delivery.db"
    redis_url: str = "redis://localhost:6379/0"
    aws_access_key_id: str = "AWS_ACCESS_KEY_ID_PLACEHOLDER"
    aws_secret_access_key: str = "AWS_SECRET_ACCESS_KEY_PLACEHOLDER"
    aws_region_name: str = "us-east-1"
    ses_sender_email: str = "no-reply@example.com"
    allowed_origins: List[str] = ["http://localhost", "http://localhost:3000"]
    rate_limit_per_minute: int = 120

    model_config = SettingsConfigDict(env_file=".env", env_file_encoding="utf-8", case_sensitive=False)

    @field_validator("allowed_origins", mode="before")
    @classmethod
    def split_origins(cls, value: str | List[str]) -> List[str]:
        """Allow comma separated origins in env files."""
        if isinstance(value, str):
            return [origin.strip() for origin in value.split(",") if origin.strip()]
        return value

    @field_validator("ses_sender_email")
    @classmethod
    def validate_sender(cls, value: str) -> str:
        if "@" not in value:
            raise ValueError("ses_sender_email must contain '@'")
        return value


@lru_cache()
def get_settings() -> Settings:
    """Return a cached Settings instance for reuse across the app."""

    return Settings()


settings = get_settings()


===== .env.example =====
APP_NAME=CourierX
ENVIRONMENT=development
API_VERSION=v1
DATABASE_URL=sqlite:///./data/email_delivery.db
REDIS_URL=redis://localhost:6379/0
AWS_ACCESS_KEY_ID=AWS_ACCESS_KEY_ID_PLACEHOLDER
AWS_SECRET_ACCESS_KEY=AWS_SECRET_ACCESS_KEY_PLACEHOLDER
AWS_REGION_NAME=us-east-1
SES_SENDER_EMAIL=no-reply@example.com
ALLOWED_ORIGINS=http://localhost,http://localhost:3000
RATE_LIMIT_PER_MINUTE=120


File not found: alembic/env.py

===== Dockerfile =====
FROM python:3.13-slim

ENV PYTHONDONTWRITEBYTECODE=1 \
    PYTHONUNBUFFERED=1

WORKDIR /app

# Install system dependencies that compiled wheels might need.
RUN apt-get update \
    && apt-get install -y --no-install-recommends build-essential libpq-dev \
    && rm -rf /var/lib/apt/lists/*

COPY requirements.txt .

RUN pip install --upgrade pip \
    && pip install --no-cache-dir -r requirements.txt

COPY . .

EXPOSE 8000

CMD ["uvicorn", "src.api.app:app", "--host", "0.0.0.0", "--port", "8000"]


===== .github/workflows/docker-deploy.yml =====
name: Build and Deploy

on:
  push:
    branches:
      - main
  workflow_dispatch:

env:
  AWS_REGION: us-east-1
  ECR_REPOSITORY: email-delivery-service
  ECS_CLUSTER: email-delivery-cluster
  ECS_SERVICE: email-delivery-service

jobs:
  test-build-deploy:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      id-token: write
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.13"

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt

      - name: Run tests
        run: pytest -q

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Build and push image
        env:
          IMAGE_TAG: ${{ github.sha }}
        run: |
          docker build -t $ECR_REPOSITORY:$IMAGE_TAG -t $ECR_REPOSITORY:latest .
          docker tag $ECR_REPOSITORY:$IMAGE_TAG ${{ steps.login-ecr.outputs.registry }}/$ECR_REPOSITORY:$IMAGE_TAG
          docker tag $ECR_REPOSITORY:latest ${{ steps.login-ecr.outputs.registry }}/$ECR_REPOSITORY:latest
          docker push ${{ steps.login-ecr.outputs.registry }}/$ECR_REPOSITORY:$IMAGE_TAG
          docker push ${{ steps.login-ecr.outputs.registry }}/$ECR_REPOSITORY:latest

      - name: Force ECS deployment
        if: ${{ env.ECS_CLUSTER != '' && env.ECS_SERVICE != '' }}
        run: |
          aws ecs update-service \
            --cluster $ECS_CLUSTER \
            --service $ECS_SERVICE \
            --force-new-deployment


